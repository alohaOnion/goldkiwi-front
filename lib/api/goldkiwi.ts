/**
 * Generated by orval v7.21.0 üç∫
 * Do not edit manually.
 * GoldKiwi Auth API
 * Ïù∏Ï¶ù API Î¨∏ÏÑú
 * OpenAPI spec version: 1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  IssueTokenDto,
  LoginDto,
  RefreshTokenDto,
  SignupDto
} from './model';

export const getAppControllerGetHelloUrl = () => {


  

  return `/api/`
}

export const appControllerGetHello = async ( options?: RequestInit): Promise<voidSuccess> => {
  
  const res = await fetch(getAppControllerGetHelloUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  if (!res.ok) {
    
    const err: globalThis.Error & {info?: any, status?: number} = new globalThis.Error();
    const data  = body ? JSON.parse(body) : {}
    err.info = data;
    err.status = res.status;
    throw err;
  }
  const data: voidSuccess = body ? JSON.parse(body) : {}
  return data
}





export const getAppControllerGetHelloQueryKey = () => {
    return [
    `/api/`
    ] as const;
    }

    
export const getAppControllerGetHelloQueryOptions = <TData = Awaited<ReturnType<typeof appControllerGetHello>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAppControllerGetHelloQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof appControllerGetHello>>> = ({ signal }) => appControllerGetHello({ signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type AppControllerGetHelloQueryResult = NonNullable<Awaited<ReturnType<typeof appControllerGetHello>>>
export type AppControllerGetHelloQueryError = unknown


export function useAppControllerGetHello<TData = Awaited<ReturnType<typeof appControllerGetHello>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof appControllerGetHello>>,
          TError,
          Awaited<ReturnType<typeof appControllerGetHello>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAppControllerGetHello<TData = Awaited<ReturnType<typeof appControllerGetHello>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof appControllerGetHello>>,
          TError,
          Awaited<ReturnType<typeof appControllerGetHello>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useAppControllerGetHello<TData = Awaited<ReturnType<typeof appControllerGetHello>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useAppControllerGetHello<TData = Awaited<ReturnType<typeof appControllerGetHello>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getAppControllerGetHelloQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * ÏÉàÎ°úÏö¥ ÏÇ¨Ïö©ÏûêÎ•º Îì±Î°ùÌï©ÎãàÎã§. usernameÍ≥º emailÏùÄ Í≥†Ïú†Ìï¥Ïïº Ìï©ÎãàÎã§.
 * @summary ÌöåÏõê Í∞ÄÏûÖ
 */
export const getAuthControllerSignupUrl = () => {


  

  return `/api/auth/signup`
}

export const authControllerSignup = async (signupDto: SignupDto, options?: RequestInit): Promise<voidSuccess> => {
  
  const res = await fetch(getAuthControllerSignupUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      signupDto,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  if (!res.ok) {
    
    const err: globalThis.Error & {info?: any, status?: number} = new globalThis.Error();
    const data  = body ? JSON.parse(body) : {}
    err.info = data;
    err.status = res.status;
    throw err;
  }
  const data: voidSuccess = body ? JSON.parse(body) : {}
  return data
}




export const getAuthControllerSignupMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerSignup>>, TError,{data: SignupDto}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof authControllerSignup>>, TError,{data: SignupDto}, TContext> => {

const mutationKey = ['authControllerSignup'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerSignup>>, {data: SignupDto}> = (props) => {
          const {data} = props ?? {};

          return  authControllerSignup(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthControllerSignupMutationResult = NonNullable<Awaited<ReturnType<typeof authControllerSignup>>>
    export type AuthControllerSignupMutationBody = SignupDto
    export type AuthControllerSignupMutationError = unknown

    /**
 * @summary ÌöåÏõê Í∞ÄÏûÖ
 */
export const useAuthControllerSignup = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerSignup>>, TError,{data: SignupDto}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authControllerSignup>>,
        TError,
        {data: SignupDto},
        TContext
      > => {

      const mutationOptions = getAuthControllerSignupMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * email ÎòêÎäî usernameÍ≥º passwordÎ°ú Ïù∏Ï¶ù ÌõÑ Ïï°ÏÑ∏Ïä§/Î¶¨ÌîÑÎ†àÏãú ÌÜ†ÌÅ∞ Î∞úÍ∏â. clientId/clientSecret Í≤ÄÏ¶ù ÌïÑÏöî. ÌÜ†ÌÅ∞ÏùÄ Ïø†ÌÇ§Ïóê ÏûêÎèô ÏÑ§Ï†ïÎê©ÎãàÎã§.
 * @summary Î°úÍ∑∏Ïù∏
 */
export const getAuthControllerLoginUrl = () => {


  

  return `/api/auth/login`
}

export const authControllerLogin = async (loginDto: LoginDto, options?: RequestInit): Promise<voidSuccess> => {
  
  const res = await fetch(getAuthControllerLoginUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      loginDto,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  if (!res.ok) {
    
    const err: globalThis.Error & {info?: any, status?: number} = new globalThis.Error();
    const data  = body ? JSON.parse(body) : {}
    err.info = data;
    err.status = res.status;
    throw err;
  }
  const data: voidSuccess = body ? JSON.parse(body) : {}
  return data
}




export const getAuthControllerLoginMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerLogin>>, TError,{data: LoginDto}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof authControllerLogin>>, TError,{data: LoginDto}, TContext> => {

const mutationKey = ['authControllerLogin'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerLogin>>, {data: LoginDto}> = (props) => {
          const {data} = props ?? {};

          return  authControllerLogin(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthControllerLoginMutationResult = NonNullable<Awaited<ReturnType<typeof authControllerLogin>>>
    export type AuthControllerLoginMutationBody = LoginDto
    export type AuthControllerLoginMutationError = unknown

    /**
 * @summary Î°úÍ∑∏Ïù∏
 */
export const useAuthControllerLogin = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerLogin>>, TError,{data: LoginDto}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authControllerLogin>>,
        TError,
        {data: LoginDto},
        TContext
      > => {

      const mutationOptions = getAuthControllerLoginMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * clientId/clientSecret Í≤ÄÏ¶ù ÌõÑ userIdÎ°ú ÏÇ¨Ïö©Ïûê Ï°∞ÌöåÌïòÏó¨ Ïï°ÏÑ∏Ïä§/Î¶¨ÌîÑÎ†àÏãú ÌÜ†ÌÅ∞ Î∞úÍ∏â (Ïø†ÌÇ§¬∑ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Í≤ÄÏ¶ùÏö©)
 * @summary ÌÜ†ÌÅ∞ Î∞úÍ∏â
 */
export const getAuthControllerIssueTokenUrl = () => {


  

  return `/api/auth/token`
}

export const authControllerIssueToken = async (issueTokenDto: IssueTokenDto, options?: RequestInit): Promise<voidSuccess> => {
  
  const res = await fetch(getAuthControllerIssueTokenUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      issueTokenDto,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  if (!res.ok) {
    
    const err: globalThis.Error & {info?: any, status?: number} = new globalThis.Error();
    const data  = body ? JSON.parse(body) : {}
    err.info = data;
    err.status = res.status;
    throw err;
  }
  const data: voidSuccess = body ? JSON.parse(body) : {}
  return data
}




export const getAuthControllerIssueTokenMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerIssueToken>>, TError,{data: IssueTokenDto}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof authControllerIssueToken>>, TError,{data: IssueTokenDto}, TContext> => {

const mutationKey = ['authControllerIssueToken'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerIssueToken>>, {data: IssueTokenDto}> = (props) => {
          const {data} = props ?? {};

          return  authControllerIssueToken(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthControllerIssueTokenMutationResult = NonNullable<Awaited<ReturnType<typeof authControllerIssueToken>>>
    export type AuthControllerIssueTokenMutationBody = IssueTokenDto
    export type AuthControllerIssueTokenMutationError = unknown

    /**
 * @summary ÌÜ†ÌÅ∞ Î∞úÍ∏â
 */
export const useAuthControllerIssueToken = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerIssueToken>>, TError,{data: IssueTokenDto}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authControllerIssueToken>>,
        TError,
        {data: IssueTokenDto},
        TContext
      > => {

      const mutationOptions = getAuthControllerIssueTokenMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Î¶¨ÌîÑÎ†àÏãú ÌÜ†ÌÅ∞: body ÎòêÎäî Ïø†ÌÇ§(refreshToken). clientId/clientSecret Í≤ÄÏ¶ù ÌõÑ ÏÉà Ïåç Î∞úÍ∏â.
 * @summary ÌÜ†ÌÅ∞ Í∞±Ïã†
 */
export const getAuthControllerRefreshUrl = () => {


  

  return `/api/auth/refresh`
}

export const authControllerRefresh = async (refreshTokenDto: RefreshTokenDto, options?: RequestInit): Promise<voidSuccess> => {
  
  const res = await fetch(getAuthControllerRefreshUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      refreshTokenDto,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  if (!res.ok) {
    
    const err: globalThis.Error & {info?: any, status?: number} = new globalThis.Error();
    const data  = body ? JSON.parse(body) : {}
    err.info = data;
    err.status = res.status;
    throw err;
  }
  const data: voidSuccess = body ? JSON.parse(body) : {}
  return data
}




export const getAuthControllerRefreshMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerRefresh>>, TError,{data: RefreshTokenDto}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof authControllerRefresh>>, TError,{data: RefreshTokenDto}, TContext> => {

const mutationKey = ['authControllerRefresh'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerRefresh>>, {data: RefreshTokenDto}> = (props) => {
          const {data} = props ?? {};

          return  authControllerRefresh(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthControllerRefreshMutationResult = NonNullable<Awaited<ReturnType<typeof authControllerRefresh>>>
    export type AuthControllerRefreshMutationBody = RefreshTokenDto
    export type AuthControllerRefreshMutationError = unknown

    /**
 * @summary ÌÜ†ÌÅ∞ Í∞±Ïã†
 */
export const useAuthControllerRefresh = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerRefresh>>, TError,{data: RefreshTokenDto}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authControllerRefresh>>,
        TError,
        {data: RefreshTokenDto},
        TContext
      > => {

      const mutationOptions = getAuthControllerRefreshMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Î¶¨ÌîÑÎ†àÏãú ÌÜ†ÌÅ∞: body ÎòêÎäî Ïø†ÌÇ§(refreshToken). clientId/clientSecret Í≤ÄÏ¶ù ÌõÑ Î¨¥Ìö®Ìôî.
 * @summary Î¶¨ÌîÑÎ†àÏãú ÌÜ†ÌÅ∞ Î¨¥Ìö®Ìôî
 */
export const getAuthControllerRevokeUrl = () => {


  

  return `/api/auth/revoke`
}

export const authControllerRevoke = async (refreshTokenDto: RefreshTokenDto, options?: RequestInit): Promise<voidSuccess> => {
  
  const res = await fetch(getAuthControllerRevokeUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      refreshTokenDto,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  if (!res.ok) {
    
    const err: globalThis.Error & {info?: any, status?: number} = new globalThis.Error();
    const data  = body ? JSON.parse(body) : {}
    err.info = data;
    err.status = res.status;
    throw err;
  }
  const data: voidSuccess = body ? JSON.parse(body) : {}
  return data
}




export const getAuthControllerRevokeMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerRevoke>>, TError,{data: RefreshTokenDto}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof authControllerRevoke>>, TError,{data: RefreshTokenDto}, TContext> => {

const mutationKey = ['authControllerRevoke'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerRevoke>>, {data: RefreshTokenDto}> = (props) => {
          const {data} = props ?? {};

          return  authControllerRevoke(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthControllerRevokeMutationResult = NonNullable<Awaited<ReturnType<typeof authControllerRevoke>>>
    export type AuthControllerRevokeMutationBody = RefreshTokenDto
    export type AuthControllerRevokeMutationError = unknown

    /**
 * @summary Î¶¨ÌîÑÎ†àÏãú ÌÜ†ÌÅ∞ Î¨¥Ìö®Ìôî
 */
export const useAuthControllerRevoke = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerRevoke>>, TError,{data: RefreshTokenDto}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authControllerRevoke>>,
        TError,
        {data: RefreshTokenDto},
        TContext
      > => {

      const mutationOptions = getAuthControllerRevokeMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }

/**
 * Î¶¨ÌîÑÎ†àÏãú ÌÜ†ÌÅ∞ Î¨¥Ìö®Ìôî ÌõÑ accessToken/refreshToken Ïø†ÌÇ§ ÏÇ≠Ï†ú. clientId/clientSecret ÌïÑÏöî.
 * @summary Î°úÍ∑∏ÏïÑÏõÉ
 */
export const getAuthControllerLogoutUrl = () => `/api/auth/logout`;

export const authControllerLogout = async (
  refreshTokenDto: RefreshTokenDto,
  options?: RequestInit,
): Promise<{ ok: boolean }> => {
  const res = await fetch(getAuthControllerLogoutUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(refreshTokenDto),
  });
  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  if (!res.ok) {
    const err: Error & { info?: unknown; status?: number } = new Error();
    err.info = body ? JSON.parse(body) : {};
    err.status = res.status;
    throw err;
  }
  return body ? JSON.parse(body) : { ok: true };
};

export const getAuthControllerLogoutMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof authControllerLogout>>,
      TError,
      { data: RefreshTokenDto },
      TContext
    >;
    fetch?: RequestInit;
  },
) => {
  const mutationKey = ["authControllerLogout"];
  const { mutation: mutationOptions, fetch: fetchOptions } = options ?? {};
  const mergedMutation =
    mutationOptions && "mutationKey" in mutationOptions
      ? mutationOptions
      : { ...mutationOptions, mutationKey };
  return {
    mutationKey,
    mutationFn: ({ data }: { data: RefreshTokenDto }) =>
      authControllerLogout(data, fetchOptions),
    ...mergedMutation,
  };
};

export const useAuthControllerLogout = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof authControllerLogout>>,
      TError,
      { data: RefreshTokenDto },
      TContext
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
) => useMutation(getAuthControllerLogoutMutationOptions(options), queryClient);

/**
 * Ïï°ÏÑ∏Ïä§ ÌÜ†ÌÅ∞: Ïø†ÌÇ§(accessToken) ÎòêÎäî Authorization Bearer. public.keyÎ°ú Í≤ÄÏ¶ù ÌõÑ payload Î∞òÌôò.
 * @summary ÌòÑÏû¨ ÏÇ¨Ïö©Ïûê
 */
export const getAuthControllerMeUrl = () => {


  

  return `/api/auth/me`
}

export const authControllerMe = async ( options?: RequestInit): Promise<voidSuccess> => {
  
  const res = await fetch(getAuthControllerMeUrl(),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  if (!res.ok) {
    
    const err: globalThis.Error & {info?: any, status?: number} = new globalThis.Error();
    const data  = body ? JSON.parse(body) : {}
    err.info = data;
    err.status = res.status;
    throw err;
  }
  const data: voidSuccess = body ? JSON.parse(body) : {}
  return data
}




export const getAuthControllerMeMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerMe>>, TError,void, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof authControllerMe>>, TError,void, TContext> => {

const mutationKey = ['authControllerMe'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerMe>>, void> = () => {
          

          return  authControllerMe(fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthControllerMeMutationResult = NonNullable<Awaited<ReturnType<typeof authControllerMe>>>
    
    export type AuthControllerMeMutationError = unknown

    /**
 * @summary ÌòÑÏû¨ ÏÇ¨Ïö©Ïûê
 */
export const useAuthControllerMe = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerMe>>, TError,void, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authControllerMe>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getAuthControllerMeMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
